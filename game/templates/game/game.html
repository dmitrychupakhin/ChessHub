{% extends "game/game-base.html" %}
{% load static %}

{% block head %}
<link type="text/css" href="{% static 'game/css/game-base.css' %}" rel="stylesheet">
<link type="text/css" href="{% static 'game/css/game.css' %}" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
    integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU" crossorigin="anonymous">
<title>ChessHub</title>
{% endblock head %}

{% block content %}
<div class="game-over-wrapper" id="gameOverWrapper">
    <div class="game-over-wrapper-title" id="gameOverTitleWrapper">Game Over</div>
    <button class="game-over-wrapper-button rematch-button" id="rematchButton">Rematch!</button>
    <button class="game-over-wrapper-button" id="homeButton">Home</button>
</div>
<div class="content">
    <div class="chess-wrapper">
        <div class="board-top">
            <div class="username-top" id="username-top">user</div>
            <div class="timer-top" id="timerTop">time</div>
        </div>
        <div class="chess-board-wrapper">
            <div id="myBoard" class="chess-board"></div>
        </div>
        <div class="board-bottom">
            <div class="username-top" id="username-bottom">{{ user.username}}</div>
            <div class="timer-bottom" id="timerBottom">time</div>
        </div>
    </div>
    <div class="display-wrapper">
        <div class="game-steps" id="gameSteps">
            none
        </div>
        <div class="evaluation">
            <div class="evaluation_title">Evaluation: </div>
            <div class="evaluation_value" id="evaluationValue">0.00</div>
        </div>
        <div class="display-buttons">
            <button class="display-button">Draw</button>
        </div>
        <div class="chat">
            <div class="messages">
                <div class="message">
                    <div class="message-user">aboba</div>
                    <div class="message-text">Привет!</div>
                </div>
            </div>
            <div class="chat-form">
                <input class="chat-input" type="text">
                <button class="chat-button">Send!</button>
            </div>
        </div>
    </div>
</div>
<script src="{% static 'game/js/chess.js' %}"></script>
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<script src="{% static 'game/js/chessboard-1.0.0.min.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/stockfish@16.0.0/src/stockfish-nnue-16.min.js"></script>
<script>

    var b1 = document.getElementById('homeButton');
    b1.addEventListener('click', function () {
        window.location.href = "{% url 'game-home' %}"
    });

    var b2 = document.getElementById('rematchButton');
    b2.addEventListener('click', function () {
        var data = {
            type: 'rematch',
        };
        socket.send(JSON.stringify(data));
    });

    const socket = new WebSocket(`ws://${window.location.host}/ws/game/{{ game_id }}/`);

    socket.onopen = (event) => {
        console.log('WebSocket connection opened:', event);
        var data = {
            type: 'game-data',
        };
        socket.send(JSON.stringify(data));
    };
    socket.onmessage = (event) => {
        console.log(event.data);
        var data = JSON.parse(event.data);
        if (data.type === 'game-data') {
            game = new Chess();
            game.load_pgn(data.game_data.game_pgn);
            board = createChessboard(game.fen());
            if ('{{ user.username}}' === data.game_data.white_user) {

                is_white_user = true;
                document.getElementById('username-top').innerText = data.game_data.black_user;
                var currentDate = new Date();
                if (data.game_data.is_white_move) {
                    startTimer('timerTop', data.game_data.black_user_end_time, data.game_data.last_move_time);
                    startTimer('timerBottom', data.game_data.white_user_end_time);
                    clearInterval(topTimerInterval);
                }
                else {
                    startTimer('timerTop', data.game_data.black_user_end_time);
                    startTimer('timerBottom', data.game_data.white_user_end_time, data.game_data.last_move_time);
                    clearInterval(bottomTimerInterval);
                }
                if (data.game_data.is_finished) {
                    var currentDate = new Date();
                    startTimer('timerBottom', currentDate + data.game_data.white_user_end_time);
                    startTimer('timerTop', currentDate + data.game_data.black_user_end_time);
                    clearInterval(topTimerInterval);
                    clearInterval(bottomTimerInterval);
                }
            }
            else {
                is_white_user = false;
                flipBoard();
                document.getElementById('username-top').innerText = data.game_data.white_user;

                if (data.game_data.is_white_move) {
                    startTimer('timerTop', data.game_data.white_user_end_time);
                    startTimer('timerBottom', data.game_data.black_user_end_time, data.game_data.last_move_time);
                    clearInterval(bottomTimerInterval);
                }
                else {
                    startTimer('timerTop', data.game_data.white_user_end_time, data.game_data.last_move_time);
                    startTimer('timerBottom', data.game_data.black_user_end_time);
                    clearInterval(topTimerInterval);
                }
                if (data.game_data.is_finished) {
                    var currentDate = new Date();
                    startTimer('timerTop', currentDate + data.game_data.white_user_end_time);
                    startTimer('timerBottom', currentDate + data.game_data.black_user_end_time);
                    clearInterval(topTimerInterval);
                    clearInterval(bottomTimerInterval);
                }
            }

            if (game.in_checkmate()) {
                var winner = game.turn() === 'w' ? 'Black' : 'White';
                document.getElementById('gameOverWrapper').style.display = 'grid';
                document.getElementById('gameOverTitleWrapper').innerText = "Checkmate!" + winner + " wins!";
                clearInterval(topTimerInterval);
                clearInterval(bottomTimerInterval);
            }
            updateMoveList();
            getEvaluation();
        }
        else if (data.type === 'rematch') {
            if (data.game_id) {
                window.location.replace(`/game/${data.game_id}/`);
            }
        }
        else if (data.type === 'game-move') {
            if (data.user !== '{{ user.username }}') {
                game.move(data.move);
                board.position(game.fen());
                updateMoveList();
                getEvaluation();
                if (game.in_checkmate()) {
                    var winner = game.turn() === 'w' ? 'Black' : 'White';
                    document.getElementById('gameOverWrapper').style.display = 'grid';
                    document.getElementById('gameOverTitleWrapper').innerText = "Checkmate!" + winner + " wins!";
                }
            }
            if (is_white_user) {
                stopTimer(topTimerInterval);
                stopTimer(bottomTimerInterval);
                startTimer('timerTop', data.black_user_end_time);
                startTimer('timerBottom', data.white_user_end_time);
                console.log(game.turn());
                if (game.turn() === 'w') {
                    stopTimer(topTimerInterval);
                } else {
                    stopTimer(bottomTimerInterval);
                }
            } else {
                stopTimer(topTimerInterval);
                stopTimer(bottomTimerInterval);
                startTimer('timerTop', data.white_user_end_time);
                startTimer('timerBottom', data.black_user_end_time);
                console.log(game.turn());
                if (game.turn() === 'w') {
                    stopTimer(bottomTimerInterval);
                } else {
                    stopTimer(topTimerInterval);
                }
            }
        }
    };
    socket.onclose = function (event) {
        console.log('WebSocket connection closed:', event);
    };

    var topTimerInterval, bottomTimerInterval;

    function stopTimer(timerInterval) {
        if (timerInterval) {
            clearInterval(timerInterval);
        }
    }

    function updateTimer(timerId, endDate, timerInterval, lastMoveTime) {
        var currentDate = new Date();
        var lastMoveDate = new Date(lastMoveTime);
        var endDate = new Date(endDate);
        if (lastMoveTime) {
            var timeDifference = currentDate - lastMoveDate;
            endDate.setTime(endDate.getTime() + timeDifference);
        }
        var timerElement = document.getElementById(timerId);
        var timeDifference = endDate - currentDate;
        if (timeDifference > 0) {
            var days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
            var hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            var minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));
            var seconds = Math.floor((timeDifference % (1000 * 60)) / 1000);

            timerElement.textContent = `${days}d ${hours}h ${minutes}m ${seconds}c`;

        } else {
            clearInterval(topTimerInterval);
            clearInterval(bottomTimerInterval);
            timerElement.textContent = "The timer has expired";
            var winner = game.turn() === 'w' ? 'Black' : 'White';
            document.getElementById('gameOverWrapper').style.display = 'grid';
            document.getElementById('gameOverTitleWrapper').innerText = "Checkmate!" + winner + " wins!";
            var data = {
                type: 'end-game',
            };
            socket.send(JSON.stringify(data));

        }
    }

    function startTimer(timerId, endDate, lastMoveTime) {
        var timerInterval;  // создаем новый интервал для каждого таймера
        if (timerId === 'timerTop') {
            updateTimer(timerId, endDate, topTimerInterval, lastMoveTime);
            topTimerInterval = setInterval(function () {
                updateTimer(timerId, endDate, topTimerInterval, lastMoveTime);
            }, 1000);
        } else if (timerId === 'timerBottom') {
            updateTimer(timerId, endDate, bottomTimerInterval, lastMoveTime);
            bottomTimerInterval = setInterval(function () {
                updateTimer(timerId, endDate, bottomTimerInterval, lastMoveTime);
            }, 1000);
        }
    }

    function flipBoard() {
        board.orientation('black');
    }

    var is_white_user = true;
    var board = null;
    var game = null;
    var whiteSquareGrey = '#a9a9a9';
    var blackSquareGrey = '#696969';

    function removeGreySquares() {
        $('#myBoard .square-55d63').css('background', '')
    }

    function greySquare(square) {
        var $square = $('#myBoard .square-' + square)

        var background = whiteSquareGrey
        if ($square.hasClass('black-3c85d')) {
            background = blackSquareGrey
        }

        $square.css('background', background)
    }


    function onDragStart(source, piece) {

        // do not pick up pieces if the game is over
        if (game.game_over()) return false

        if (is_white_user && game.turn() === 'b') {
            return false;
        }
        else if (is_white_user === false && game.turn() === 'w') {
            return false;
        }

        // or if it's not that side's turn
        if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
            (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
            return false
        }
    }

    function onDrop(source, target) {
        removeGreySquares()
        // see if the move is legal
        var move = game.move({
            from: source,
            to: target,
            promotion: 'q' // NOTE: always promote to a queen for example simplicity
        })

        // illegal move
        if (move === null) return 'snapback'

        setTimeout(function () {
            // Check if the game is over (checkmate)
            if (game.in_checkmate()) {
                var winner = game.turn() === 'w' ? 'Black' : 'White';
                document.getElementById('gameOverWrapper').style.display = 'grid';
                document.getElementById('gameOverTitleWrapper').innerText = "Checkmate!" + winner + " wins!";
            }
            getEvaluation();
        }, 150);
    }

    function onMouseoverSquare(square, piece) {
        if (piece && piece.charAt(0) === 'b' && is_white_user) {
            return;
        }
        else if (piece && piece.charAt(0) === 'w' && is_white_user == false) {
            return;
        }
        // get list of possible moves for this square
        var moves = game.moves({
            square: square,
            verbose: true
        })
        // exit if there are no moves available for this square
        if (moves.length === 0) return
        // highlight the square they moused over
        greySquare(square)

        // highlight the possible squares for this piece
        for (var i = 0; i < moves.length; i++) {
            greySquare(moves[i].to)
        }

    }

    function onMouseoutSquare(square, piece) {
        removeGreySquares()
    }

    function onSnapEnd() {
        board.position(game.fen())
        const history = game.history();
        var move = history[history.length - 1];
        var gamePGN = game.pgn(true);
        var moves = gamePGN.split(' ');
        updateMoveList();
        var data = {
            type: 'move',
            move: move,
            gamePGN: gamePGN
        };
        socket.send(JSON.stringify(data));
    }


    var config = {
        draggable: true,
        position: 'start',
        pieceTheme: "{% static '/game/img/chesspieces/wikipedia/' %}" + '{piece}.png',
        sparePieces: false,
        showNotation: true,
        onDragStart: onDragStart,
        onDrop: onDrop,
        onMouseoutSquare: onMouseoutSquare,
        onMouseoverSquare: onMouseoverSquare,
        onSnapEnd: onSnapEnd,
    };

    var board = Chessboard('myBoard', config);

    var boardElement = document.getElementById('myBoard');

    boardElement.addEventListener('touchstart', function (e) {
        e.preventDefault();
        var touch = e.touches[0];
        onDragStart(board, touch);
        isDragging = true;
    }, false);

    boardElement.addEventListener('touchmove', function (e) {
        e.preventDefault();
        if (isDragging) {
            var touch = e.touches[0];
            onDrop(board, touch);
        }
    }, false);

    boardElement.addEventListener('touchend', function (e) {
        e.preventDefault();
        isDragging = false;
    }, false);

    var currentFEN = '';

    var createChessboard = function (fen) {
        return Chessboard('myBoard', {
            ...config,
            position: fen || 'start' // Используем переданный FEN или 'start', если FEN не предоставлен
        });
    };

    window.addEventListener('resize', function () {
        currentFEN = board.fen();
        // Удаляем или скрываем предыдущую доску
        board.destroy();
        // Создаем новую доску с теми же конфигурационными значениями
        board = createChessboard(currentFEN);

        if (is_white_user == false) {
            flipBoard();
        }
    });

    var stockfish = new Worker("{% static 'game/js/stockfish.js' %}");



    function updateMoveList() {
        var pgnString = "";

        // Получаем массив ходов
        var moves_verbose = game.history({ verbose: true });

        // Добавляем каждый ход в строку
        for (var i = 0; i < moves_verbose.length; i++) {
            if (i % 2 === 0) {
                // Добавляем номер хода, если это первый ход пары
                pgnString += ((i / 2) + 1) + ". ";
            }

            // Добавляем алгебраическую нотацию хода
            pgnString += moves_verbose[i].san + " ";

            // Добавляем перевод строки после второго хода пары
            if (i % 2 === 1) {
                pgnString += "\n";
            }
        }
        document.getElementById('gameSteps').innerText = pgnString;
        document.getElementById('gameSteps').scrollTop = document.getElementById('gameSteps').scrollHeight;
        if (game.in_checkmate()) {
            var winner = game.turn() === 'w' ? 'Black' : 'White';
            document.getElementById('gameOverWrapper').style.display = 'grid';
            document.getElementById('gameOverTitleWrapper').innerText = "Checkmate!" + winner + " wins!";
        }
    }

    function getEvaluation() {
        // Получаем оценку позиции от Stockfish
        stockfish.postMessage('position fen ' + game.fen());
        stockfish.postMessage('eval');

        // Обрабатываем ответ от Stockfish
        stockfish.onmessage = function (event) {
            var match = event.data.match(/Total Evaluation: ([0-9.-]+)/);

            if (match && match[1]) {
                var evaluation = parseFloat(match[1]);
                document.getElementById('evaluationValue').innerText = evaluation;
            }
        };
    }

</script>
{% endblock content %}